<!DOCTYPE html>
<html>
<head>
  <title>Ramadan Pen - Light Blue Edition</title>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
  <style>
    * { box-sizing: border-box; }
    
    body { 
      margin: 0; 
      background: #050a0a; 
      overflow: hidden; 
      font-family: 'Courier New', monospace;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      width: 100vw;
    }
    
    /* Container enlarged and color changed to Light Blue */
    .container {
      position: relative;
      width: 85vw; /* تكبير العرض */
      height: 85vh; /* تكبير الطول */
      max-width: 1200px;
      max-height: 900px;
      min-width: 400px;
      min-height: 300px;
    }
    
    /* Ring light border effect - Light Blue Theme */
    .container::before {
      content: '';
      position: absolute;
      top: -20px;
      left: -20px;
      right: -20px;
      bottom: -20px;
      border-radius: 30px;
      background: linear-gradient(45deg, #00d4ff, #008fb3, #00d4ff, #005f73, #00d4ff);
      background-size: 400% 400%;
      z-index: -1;
      animation: ringPulse 3s ease infinite;
      box-shadow: 
        0 0 60px rgba(0, 212, 255, 0.6),
        0 0 100px rgba(0, 212, 255, 0.3),
        inset 0 0 60px rgba(0, 212, 255, 0.2);
    }
    
    @keyframes ringPulse {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }
    
    /* Inner glow overlay */
    .container::after {
      content: '';
      position: absolute;
      top: -10px;
      left: -10px;
      right: -10px;
      bottom: -10px;
      border-radius: 20px;
      border: 2px solid rgba(0, 212, 255, 0.5);
      box-shadow: 
        inset 0 0 30px rgba(0, 212, 255, 0.2),
        0 0 20px rgba(0, 212, 255, 0.4);
      pointer-events: none;
      z-index: 10;
    }
    
    video {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform: scaleX(-1);
      z-index: 0;
      opacity: 0.6;
      filter: contrast(1.1) brightness(0.9);
      border-radius: 12px;
    }
    
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      transform: scaleX(-1);
      z-index: 1;
      border-radius: 12px;
    }
    
    #ui {
      position: absolute; 
      top: 20px; 
      left: 20px; 
      z-index: 20;
      color: #00d4ff; 
      font-size: 11px; 
      opacity: 0.95;
      text-shadow: 0 0 10px rgba(0, 212, 255, 0.9), 0 0 20px rgba(0,0,0,0.9);
      pointer-events: none;
    }
    .instruction { 
      margin: 4px 0; 
      background: rgba(0,0,0,0.7); 
      padding: 4px 8px; 
      display: inline-block;
      border-radius: 4px;
      border: 1px solid rgba(0, 212, 255, 0.3);
    }
    
    .corner {
      position: absolute;
      width: 30px;
      height: 30px;
      border: 2px solid rgba(0, 212, 255, 0.6);
      z-index: 15;
      pointer-events: none;
    }
    .corner-tl { top: -5px; left: -5px; border-right: none; border-bottom: none; }
    .corner-tr { top: -5px; right: -5px; border-left: none; border-bottom: none; }
    .corner-bl { bottom: -5px; left: -5px; border-right: none; border-top: none; }
    .corner-br { bottom: -5px; right: -5px; border-left: none; border-top: none; }
    
    .resize-hint {
      position: absolute;
      bottom: 10px;
      right: 10px;
      color: rgba(0, 212, 255, 0.5);
      font-size: 10px;
      z-index: 20;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div class="container" id="container">
    <div class="corner corner-tl"></div>
    <div class="corner corner-tr"></div>
    <div class="corner corner-bl"></div>
    <div class="corner corner-br"></div>
    
    <div id="ui">
      <div class="instruction">[R] hold to draw</div>
      <div class="instruction">[SPACE] clear canvas</div>
      <div class="instruction">[S] save drawing</div>
    </div>
    
    <div class="resize-hint">resize window freely</div>
    
    <video id="vid" playsinline></video>
    <canvas id="c"></canvas>
  </div>
  
  <script>
    // Filters and Classes remain same
    class KalmanFilter {
      constructor(R = 0.008, Q = 0.12) {
        this.R = R; this.Q = Q; this.P = 1; this.X = 0; this.K = 0;
      }
      update(measurement) {
        this.P = this.P + this.Q;
        this.K = this.P / (this.P + this.R);
        this.X = this.X + this.K * (measurement - this.X);
        this.P = (1 - this.K) * this.P;
        return this.X;
      }
      reset() { this.P = 1; this.X = 0; }
    }

    class OneEuroFilter {
      constructor(freq = 60, mincutoff = 0.8, beta = 0.005, dcutoff = 1.0) {
        this.freq = freq; this.mincutoff = mincutoff; this.beta = beta; this.dcutoff = dcutoff;
        this.x_prev = null; this.dx_prev = null; this.t_prev = null;
      }
      smoothingFactor(t, cutoff) { const r = 2 * Math.PI * cutoff * t; return r / (r + 1); }
      exponentialSmoothing(x, x_prev, alpha) { return alpha * x + (1 - alpha) * x_prev; }
      filter(x, t) {
        if (this.x_prev === null) { this.x_prev = x; this.dx_prev = 0; this.t_prev = t; return x; }
        const t_e = t - this.t_prev;
        const dx = (x - this.x_prev) / t_e;
        const dx_hat = this.exponentialSmoothing(dx, this.dx_prev, this.smoothingFactor(t_e, this.dcutoff));
        const cutoff = this.mincutoff + this.beta * Math.abs(dx_hat);
        const x_hat = this.exponentialSmoothing(x, this.x_prev, this.smoothingFactor(t_e, cutoff));
        this.x_prev = x_hat; this.dx_prev = dx_hat; this.t_prev = t;
        return x_hat;
      }
      reset() { this.x_prev = null; this.dx_prev = null; this.t_prev = null; }
    }

    const vec2 = { dist: (a, b) => Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2) };

    var vid = document.getElementById('vid');
    var c = document.getElementById('c');
    var ctx = c.getContext('2d');
    var container = document.getElementById('container');
    
    var containerRect = null;
    var scaleX = 1; var scaleY = 1;
    var strokes = []; var currentStroke = [];
    var isDrawing = false;
    var rKeyPressed = false; // التغيير هنا لمفتاح R
    
    var kf_x = new KalmanFilter(0.006, 0.1);
    var kf_y = new KalmanFilter(0.006, 0.1);
    var euro_x = new OneEuroFilter(60, 0.4, 0.008, 1.0);
    var euro_y = new OneEuroFilter(60, 0.4, 0.008, 1.0);
    
    var rawPos = null; var smoothPos = null; var finalPos = null;
    var lastPos = null; var velocity = { x: 0, y: 0 }; var speed = 0;
    var handDetected = false; var lostHandTimer = 0; var zDepth = 0;
    var detectionQuality = 0; var lastTime = performance.now(); var fps = 60;

    function updateDimensions() {
      containerRect = container.getBoundingClientRect();
      if (c.width !== containerRect.width || c.height !== containerRect.height) {
        c.width = containerRect.width;
        c.height = containerRect.height;
      }
      scaleX = containerRect.width;
      scaleY = containerRect.height;
    }

    window.addEventListener('resize', updateDimensions);
    updateDimensions();

    window.onkeydown = function(e) {
      if (e.key === 'r' || e.key === 'R') rKeyPressed = true; // تفعيل الرسم عند الضغط على R
      if (e.code === 'Space') { strokes = []; currentStroke = []; }
      if (e.key === 's' || e.key === 'S') saveDrawing();
    };
    
    window.onkeyup = function(e) {
      if (e.key === 'r' || e.key === 'R') { // إيقاف الرسم عند رفع اليد عن R
        rKeyPressed = false;
        isDrawing = false;
        if (currentStroke.length > 0) {
          strokes.push([...currentStroke]);
          currentStroke = [];
        }
      }
    };

    function saveDrawing() {
      const link = document.createElement('a');
      link.download = 'drawing-' + Date.now() + '.png';
      link.href = c.toDataURL();
      link.click();
    }

    function processLandmarks(lm) {
      const now = performance.now();
      const dt = (now - lastTime) / 1000;
      lastTime = now;
      const ind = lm[8];
      detectionQuality = (ind.visibility || 0.8);
      zDepth = ind.z || 0;
      const rx = ind.x * scaleX;
      const ry = ind.y * scaleY;
      const kx = kf_x.update(rx);
      const ky = kf_y.update(ry);
      const ex = euro_x.filter(kx, now);
      const ey = euro_y.filter(ky, now);
      finalPos = { x: ex, y: ey };
      if (lastPos) {
        velocity.x = (finalPos.x - lastPos.x) / dt;
        velocity.y = (finalPos.y - lastPos.y) / dt;
        speed = Math.sqrt(velocity.x ** 2 + velocity.y ** 2);
      }
      lastPos = { ...finalPos };
      handDetected = true;
      lostHandTimer = 0;
      return finalPos;
    }

    function drawStroke(stroke, alpha = 1) {
      if (stroke.length < 2) return;
      ctx.beginPath();
      ctx.moveTo(stroke[0].x, stroke[0].y);
      for (let i = 1; i < stroke.length - 1; i++) {
        const xc = (stroke[i].x + stroke[i + 1].x) / 2;
        const yc = (stroke[i].y + stroke[i + 1].y) / 2;
        ctx.quadraticCurveTo(stroke[i].x, stroke[i].y, xc, yc);
      }
      ctx.globalAlpha = alpha;
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    function run(res) {
      updateDimensions();
      ctx.clearRect(0, 0, c.width, c.height);
      
      // Blue theme styling
      ctx.shadowColor = '#00d4ff';
      ctx.shadowBlur = 15;
      ctx.strokeStyle = '#00d4ff';
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      
      for (let stroke of strokes) {
        ctx.lineWidth = 4;
        drawStroke(stroke);
      }
      
      if (currentStroke.length > 0) {
        ctx.lineWidth = Math.max(2, 6 - speed * 0.1);
        drawStroke(currentStroke);
      }
      
      if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
        const lm = res.multiHandLandmarks[0];
        const scaledLm = lm.map(p => ({ x: p.x * scaleX, y: p.y * scaleY, z: p.z }));
        
        ctx.shadowBlur = 0;
        drawConnectors(ctx, scaledLm, HAND_CONNECTIONS, { color: 'rgba(0, 212, 255, 0.2)', lineWidth: 1 });
        
        const pos = processLandmarks(lm);
        ctx.shadowBlur = 20;
        ctx.fillStyle = rKeyPressed ? '#FFFFFF' : '#00d4ff';
        
        const zFactor = Math.max(0.5, Math.min(1.5, 1 - zDepth * 2));
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, 8 * zFactor, 0, 2 * Math.PI);
        ctx.fill();
        
        if (rKeyPressed) {
          if (!isDrawing) {
            isDrawing = true;
            currentStroke = [{ x: pos.x, y: pos.y }];
          } else {
            const lastPoint = currentStroke[currentStroke.length - 1];
            if (vec2.dist(pos, lastPoint) > 2) {
              currentStroke.push({ x: pos.x, y: pos.y });
            }
          }
        }
      }
    }

    var h = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
    h.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
    h.onResults(run);

    var cam = new Camera(vid, {
      onFrame: async () => { await h.send({image: vid}); },
      width: 1280, height: 720
    });
    cam.start();
  </script>
</body>
</html>
