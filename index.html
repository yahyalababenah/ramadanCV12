<!DOCTYPE html>
<html>
<head>
  <title>ramadan pen - pro</title>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
  <style>
    * { box-sizing: border-box; }
    
    body { 
      margin: 0; 
      background: #0a0805; 
      overflow: hidden; 
      font-family: 'Courier New', monospace;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      width: 100vw;
    }
    
    /* Container for the ring light effect */
    .container {
      position: relative;
      width: 70vw;
      height: 70vh;
      max-width: 1000px;
      max-height: 750px;
      min-width: 400px;
      min-height: 300px;
    }
    
    /* Ring light border effect */
    .container::before {
      content: '';
      position: absolute;
      top: -20px;
      left: -20px;
      right: -20px;
      bottom: -20px;
      border-radius: 30px;
      background: linear-gradient(45deg, #F5D061, #ff9d00, #F5D061, #ff6b00, #F5D061);
      background-size: 400% 400%;
      z-index: -1;
      animation: ringPulse 3s ease infinite;
      box-shadow: 
        0 0 60px rgba(245, 208, 97, 0.6),
        0 0 100px rgba(245, 208, 97, 0.3),
        inset 0 0 60px rgba(245, 208, 97, 0.2);
    }
    
    @keyframes ringPulse {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }
    
    /* Inner glow overlay */
    .container::after {
      content: '';
      position: absolute;
      top: -10px;
      left: -10px;
      right: -10px;
      bottom: -10px;
      border-radius: 20px;
      border: 2px solid rgba(245, 208, 97, 0.5);
      box-shadow: 
        inset 0 0 30px rgba(245, 208, 97, 0.2),
        0 0 20px rgba(245, 208, 97, 0.4);
      pointer-events: none;
      z-index: 10;
    }
    
    /* Video as background inside container - NO TINT */
    video {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform: scaleX(-1);
      z-index: 0;
      opacity: 0.6;
      filter: contrast(1.05) brightness(0.95);
      border-radius: 12px;
    }
    
    /* Canvas on top for drawing */
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      transform: scaleX(-1);
      z-index: 1;
      border-radius: 12px;
    }
    
    #ui {
      position: absolute; 
      top: 20px; 
      left: 20px; 
      z-index: 20;
      color: #F5D061; 
      font-size: 11px; 
      opacity: 0.95;
      text-shadow: 0 0 10px rgba(245, 208, 97, 0.9), 0 0 20px rgba(0,0,0,0.9);
      pointer-events: none;
    }
    .instruction { 
      margin: 4px 0; 
      background: rgba(0,0,0,0.7); 
      padding: 4px 8px; 
      display: inline-block;
      border-radius: 4px;
      border: 1px solid rgba(245, 208, 97, 0.3);
    }
    
    /* Corner accents */
    .corner {
      position: absolute;
      width: 30px;
      height: 30px;
      border: 2px solid rgba(245, 208, 97, 0.6);
      z-index: 15;
      pointer-events: none;
    }
    .corner-tl { top: -5px; left: -5px; border-right: none; border-bottom: none; }
    .corner-tr { top: -5px; right: -5px; border-left: none; border-bottom: none; }
    .corner-bl { bottom: -5px; left: -5px; border-right: none; border-top: none; }
    .corner-br { bottom: -5px; right: -5px; border-left: none; border-top: none; }
    
    /* Resize handle indicator */
    .resize-hint {
      position: absolute;
      bottom: 10px;
      right: 10px;
      color: rgba(245, 208, 97, 0.5);
      font-size: 10px;
      z-index: 20;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div class="container" id="container">
    <div class="corner corner-tl"></div>
    <div class="corner corner-tr"></div>
    <div class="corner corner-bl"></div>
    <div class="corner corner-br"></div>
    
    <div id="ui">
      <div class="instruction">[SHIFT] hold to draw</div>
      <div class="instruction">[SPACE] clear canvas</div>
      <div class="instruction">[S] save drawing</div>
    </div>
    
    <div class="resize-hint">resize window freely</div>
    
    <video id="vid" playsinline></video>
    <canvas id="c"></canvas>
  </div>
  
  <script>
    // ==========================================
    // KALMAN FILTER - for predictive smoothing
    // ==========================================
    class KalmanFilter {
      constructor(R = 0.008, Q = 0.12) {
        this.R = R;
        this.Q = Q;
        this.P = 1;
        this.X = 0;
        this.K = 0;
      }
      
      update(measurement) {
        this.P = this.P + this.Q;
        this.K = this.P / (this.P + this.R);
        this.X = this.X + this.K * (measurement - this.X);
        this.P = (1 - this.K) * this.P;
        return this.X;
      }
      
      reset() {
        this.P = 1;
        this.X = 0;
      }
    }

    // ==========================================
    // ONE EURO FILTER - adaptive smoothing
    // ==========================================
    class OneEuroFilter {
      constructor(freq = 60, mincutoff = 0.8, beta = 0.005, dcutoff = 1.0) {
        this.freq = freq;
        this.mincutoff = mincutoff;
        this.beta = beta;
        this.dcutoff = dcutoff;
        this.x_prev = null;
        this.dx_prev = null;
        this.t_prev = null;
      }
      
      smoothingFactor(t, cutoff) {
        const r = 2 * Math.PI * cutoff * t;
        return r / (r + 1);
      }
      
      exponentialSmoothing(x, x_prev, alpha) {
        return alpha * x + (1 - alpha) * x_prev;
      }
      
      filter(x, t) {
        if (this.x_prev === null) {
          this.x_prev = x;
          this.dx_prev = 0;
          this.t_prev = t;
          return x;
        }
        
        const t_e = t - this.t_prev;
        const dx = (x - this.x_prev) / t_e;
        const dx_hat = this.exponentialSmoothing(dx, this.dx_prev, this.smoothingFactor(t_e, this.dcutoff));
        const cutoff = this.mincutoff + this.beta * Math.abs(dx_hat);
        const x_hat = this.exponentialSmoothing(x, this.x_prev, this.smoothingFactor(t_e, cutoff));
        
        this.x_prev = x_hat;
        this.dx_prev = dx_hat;
        this.t_prev = t;
        
        return x_hat;
      }
      
      reset() {
        this.x_prev = null;
        this.dx_prev = null;
        this.t_prev = null;
      }
    }

    const vec2 = {
      dist: (a, b) => Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2),
    };

    // ==========================================
    // MAIN APP
    // ==========================================
    var vid = document.getElementById('vid');
    var c = document.getElementById('c');
    var ctx = c.getContext('2d');
    var container = document.getElementById('container');
    
    // Track container dimensions for accurate coordinate mapping
    var containerRect = null;
    var scaleX = 1;
    var scaleY = 1;
    
    var strokes = [];
    var currentStroke = [];
    var isDrawing = false;
    var shiftPressed = false;
    
    // Improved filters for windowed mode
    var kf_x = new KalmanFilter(0.006, 0.1);
    var kf_y = new KalmanFilter(0.006, 0.1);
    var euro_x = new OneEuroFilter(60, 0.4, 0.008, 1.0);
    var euro_y = new OneEuroFilter(60, 0.4, 0.008, 1.0);
    
    var rawPos = null;
    var smoothPos = null;
    var finalPos = null;
    var lastPos = null;
    var velocity = { x: 0, y: 0 };
    var speed = 0;
    
    var handDetected = false;
    var lostHandTimer = 0;
    var zDepth = 0;
    var detectionQuality = 0;
    
    var lastTime = performance.now();
    var fps = 60;

    // Update dimensions on resize
    function updateDimensions() {
      containerRect = container.getBoundingClientRect();
      // Set canvas internal resolution to match display size for sharp rendering
      if (c.width !== containerRect.width || c.height !== containerRect.height) {
        c.width = containerRect.width;
        c.height = containerRect.height;
      }
      // Calculate scale factors for coordinate mapping
      scaleX = containerRect.width;
      scaleY = containerRect.height;
    }

    window.addEventListener('resize', updateDimensions);
    updateDimensions();

    window.onkeydown = function(e) {
      if (e.key === 'Shift') shiftPressed = true;
      if (e.code === 'Space') {
        strokes = [];
        currentStroke = [];
      }
      if (e.key === 's' || e.key === 'S') saveDrawing();
    };
    
    window.onkeyup = function(e) {
      if (e.key === 'Shift') {
        shiftPressed = false;
        isDrawing = false;
        if (currentStroke.length > 0) {
          strokes.push([...currentStroke]);
          currentStroke = [];
        }
      }
    };

    function saveDrawing() {
      const link = document.createElement('a');
      link.download = 'ramadan-drawing-' + Date.now() + '.png';
      link.href = c.toDataURL();
      link.click();
    }

    function processLandmarks(lm) {
      const now = performance.now();
      const dt = (now - lastTime) / 1000;
      lastTime = now;
      fps = 0.9 * fps + 0.1 * (1 / dt);
      
      const ind = lm[8];
      const wrist = lm[0];
      const middle = lm[12];
      
      // Calculate detection quality based on landmark confidence
      detectionQuality = (ind.visibility || 0.8) * 0.5 + (wrist.visibility || 0.8) * 0.5;
      
      zDepth = ind.z || 0;
      
      // Map normalized coordinates (0-1) to container dimensions
      // MediaPipe returns normalized coordinates regardless of input resolution
      const rx = ind.x * scaleX;
      const ry = ind.y * scaleY;
      
      // Apply stronger smoothing for windowed mode stability
      const kx = kf_x.update(rx);
      const ky = kf_y.update(ry);
      
      const ex = euro_x.filter(kx, now);
      const ey = euro_y.filter(ky, now);
      
      rawPos = { x: rx, y: ry };
      smoothPos = { x: kx, y: ky };
      finalPos = { x: ex, y: ey };
      
      if (lastPos) {
        velocity.x = (finalPos.x - lastPos.x) / dt;
        velocity.y = (finalPos.y - lastPos.y) / dt;
        speed = Math.sqrt(velocity.x ** 2 + velocity.y ** 2);
      }
      lastPos = { ...finalPos };
      
      handDetected = true;
      lostHandTimer = 0;
      
      return finalPos;
    }

    function resetTracking() {
      kf_x.reset();
      kf_y.reset();
      euro_x.reset();
      euro_y.reset();
      rawPos = null;
      smoothPos = null;
      finalPos = null;
      lastPos = null;
      velocity = { x: 0, y: 0 };
      speed = 0;
      handDetected = false;
      detectionQuality = 0;
    }

    function drawStroke(stroke, alpha = 1) {
      if (stroke.length < 2) return;
      
      ctx.beginPath();
      ctx.moveTo(stroke[0].x, stroke[0].y);
      
      for (let i = 1; i < stroke.length - 1; i++) {
        const xc = (stroke[i].x + stroke[i + 1].x) / 2;
        const yc = (stroke[i].y + stroke[i + 1].y) / 2;
        ctx.quadraticCurveTo(stroke[i].x, stroke[i].y, xc, yc);
      }
      
      if (stroke.length > 1) {
        const last = stroke[stroke.length - 1];
        ctx.lineTo(last.x, last.y);
      }
      
      ctx.globalAlpha = alpha;
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    function run(res) {
      // Ensure dimensions are up to date
      updateDimensions();
      
      ctx.clearRect(0, 0, c.width, c.height);
      
      // Dynamic shadow based on detection quality
      const qualityGlow = 10 + (detectionQuality * 20);
      ctx.shadowColor = '#F5D061';
      ctx.shadowBlur = qualityGlow;
      ctx.strokeStyle = '#F5D061';
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      
      for (let stroke of strokes) {
        ctx.lineWidth = 4;
        drawStroke(stroke);
      }
      
      if (currentStroke.length > 0) {
        ctx.lineWidth = Math.max(2, 6 - speed * 0.1);
        drawStroke(currentStroke);
      }
      
      if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
        const lm = res.multiHandLandmarks[0];
        
        // Scale landmarks to container dimensions for drawing
        const scaledLm = lm.map(p => ({
          x: p.x * scaleX / c.width,
          y: p.y * scaleY / c.height,
          z: p.z
        }));
        
        ctx.shadowBlur = 0;
        drawConnectors(ctx, scaledLm, HAND_CONNECTIONS, {
          color: 'rgba(245, 208, 97, 0.2)', 
          lineWidth: 1
        });
        drawLandmarks(ctx, scaledLm, {
          color: 'rgba(255, 255, 255, 0.4)', 
          lineWidth: 1, 
          radius: 2
        });
        
        const pos = processLandmarks(lm);
        
        const speedRatio = Math.min(1, speed / 100);
        const r = Math.floor(245 + (255 - 245) * speedRatio);
        const g = Math.floor(208 - 100 * speedRatio);
        const b = Math.floor(97 - 50 * speedRatio);
        
        ctx.shadowBlur = 15 + speedRatio * 10;
        ctx.shadowColor = `rgb(${r}, ${g}, ${b})`;
        ctx.fillStyle = shiftPressed ? '#FFFFFF' : `rgba(${r}, ${g}, ${b}, 0.9)`;
        
        const zFactor = Math.max(0.5, Math.min(1.5, 1 - zDepth * 2));
        const cursorSize = 8 * zFactor;
        
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, cursorSize, 0, 2 * Math.PI);
        ctx.fill();
        
        if (speed > 5) {
          ctx.strokeStyle = 'rgba(245, 208, 97, 0.4)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(pos.x, pos.y);
          ctx.lineTo(pos.x + velocity.x * 0.05, pos.y + velocity.y * 0.05);
          ctx.stroke();
        }
        
        // Improved drawing logic with better threshold for windowed mode
        if (shiftPressed) {
          if (!isDrawing) {
            // Lower speed threshold for easier drawing in small windows
            if (speed > 5 || currentStroke.length === 0) {
              isDrawing = true;
              currentStroke = [{ x: pos.x, y: pos.y, speed: speed, z: zDepth }];
            }
          } else {
            const lastPoint = currentStroke[currentStroke.length - 1];
            const dist = vec2.dist(pos, lastPoint);
            
            // Adaptive distance threshold based on window size
            const minDist = Math.max(1.5, Math.min(3, scaleX * 0.002));
            
            if (dist > minDist) {
              currentStroke.push({ 
                x: pos.x, 
                y: pos.y, 
                speed: speed,
                z: zDepth,
                width: Math.max(2, 6 - speed * 0.05)
              });
            }
          }
        } else {
          if (isDrawing) {
            isDrawing = false;
            if (currentStroke.length > 1) {
              strokes.push([...currentStroke]);
            }
            currentStroke = [];
          }
        }
        
      } else {
        lostHandTimer++;
        if (lostHandTimer > 15) {
          if (isDrawing && currentStroke.length > 1) {
            strokes.push([...currentStroke]);
          }
          currentStroke = [];
          isDrawing = false;
          resetTracking();
        }
      }
    }

    var h = new Hands({
      locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
      }
    });
    
    h.setOptions({ 
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.6,
      minTrackingConfidence: 0.6
    });
    
    h.onResults(run);

    var cam = new Camera(vid, {
      onFrame: async () => { await h.send({image: vid}); },
      width: 1280,
      height: 720,
      facingMode: 'user'
    });
    
    cam.start();
  </script>
</body>
</html>
